! function(t) {
    "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function(e) {
        return t(e, window, document)
    }) : "object" == typeof exports ? module.exports = function(e, o) {
        return e || (e = window), o && o.fn.dataTable || (o = require("datatables.net")(e, o).$), t(o, e, e.document)
    } : t(jQuery, window, document)
}(function(t, e, o, i) {
    "use strict";
    var l, s = t.fn.dataTable,
        r = function(e, o) {
            var l = this;
            if (!(this instanceof r)) return void alert("FixedColumns warning: FixedColumns must be initialised with the 'new' keyword.");
            (o === i || o === !0) && (o = {});
            var s = t.fn.dataTable.camelToHungarian;
            s && (s(r.defaults, r.defaults, !0), s(r.defaults, o));
            var n = new t.fn.dataTable.Api(e).settings()[0];
            if (this.s = {
                    dt: n,
                    iTableColumns: n.aoColumns.length,
                    aiOuterWidths: [],
                    aiInnerWidths: [],
                    rtl: "rtl" === t(n.nTable).css("direction")
                }, this.dom = {
                    scroller: null,
                    header: null,
                    body: null,
                    footer: null,
                    grid: {
                        wrapper: null,
                        dt: null,
                        left: {
                            wrapper: null,
                            head: null,
                            body: null,
                            foot: null
                        },
                        right: {
                            wrapper: null,
                            head: null,
                            body: null,
                            foot: null
                        }
                    },
                    clone: {
                        left: {
                            header: null,
                            body: null,
                            footer: null
                        },
                        right: {
                            header: null,
                            body: null,
                            footer: null
                        }
                    }
                }, n._oFixedColumns) throw "FixedColumns already initialised on this table";
            n._oFixedColumns = this, n._bInitComplete ? this._fnConstruct(o) : n.oApi._fnCallbackReg(n, "aoInitComplete", function() {
                l._fnConstruct(o)
            }, "FixedColumns")
        };
    return t.extend(r.prototype, {

        fnUpdate: function() {
            this._fnDraw(!0)
        },
        fnRedrawLayout: function() {
            this._fnColCalc(), this._fnGridLayout(), this.fnUpdate()
        },
        fnRecalculateHeight: function(t) {
            delete t._DTTC_iHeight, t.style.height = "auto"
        },
        fnSetRowHeight: function(t, e) {
            t.style.height = e + "px"
        },
        fnGetPosition: function(e) {
            var o, i = this.s.dt.oInstance;
            if (t(e).parents(".DTFC_Cloned").length) {
                if ("tr" === e.nodeName.toLowerCase()) return o = t(e).index(), i.fnGetPosition(t("tr", this.s.dt.nTBody)[o]);
                var l = t(e).index();
                o = t(e.parentNode).index();
                var s = i.fnGetPosition(t("tr", this.s.dt.nTBody)[o]);
                return [s, l, i.oApi._fnVisibleToColumnIndex(this.s.dt, l)]
            }
            return i.fnGetPosition(e)
        },
        _fnConstruct: function(l) {
            var s = this;
            if ("function" != typeof this.s.dt.oInstance.fnVersionCheck || this.s.dt.oInstance.fnVersionCheck("1.8.0") !== !0) return void alert("FixedColumns " + r.VERSION + " required DataTables 1.8.0 or later. Please upgrade your DataTables installation");
            if ("" === this.s.dt.oScroll.sX) return void this.s.dt.oInstance.oApi._fnLog(this.s.dt, 1, "FixedColumns is not needed (no x-scrolling in DataTables enabled), so no action will be taken. Use 'FixedHeader' for column fixing when scrolling is not enabled");
            this.s = t.extend(!0, this.s, r.defaults, l);
            var n = this.s.dt.oClasses;
            this.dom.grid.dt = t(this.s.dt.nTable).parents("div." + n.sScrollWrapper)[0], this.dom.scroller = t("div." + n.sScrollBody, this.dom.grid.dt)[0], this._fnColCalc(), this._fnGridSetup();
            var d, a = !1;
            t(this.s.dt.nTableWrapper).on("mousedown.DTFC", function() {
                a = !0, t(o).one("mouseup", function() {
                    a = !1
                })
            }), t(this.dom.scroller).on("mouseover.DTFC touchstart.DTFC", function() {
                a || (d = "main")
            }).on("scroll.DTFC", function(t) {
                !d && t.originalEvent && (d = "main"), "main" === d && (s.s.iLeftColumns > 0 && (s.dom.grid.left.liner.scrollTop = s.dom.scroller.scrollTop), s.s.iRightColumns > 0 && (s.dom.grid.right.liner.scrollTop = s.dom.scroller.scrollTop))
            });
            var h = "onwheel" in o.createElement("div") ? "wheel.DTFC" : "mousewheel.DTFC";
            s.s.iLeftColumns > 0 && t(s.dom.grid.left.liner).on("mouseover.DTFC touchstart.DTFC", function() {
                a || (d = "left")
            }).on("scroll.DTFC", function(t) {
                !d && t.originalEvent && (d = "left"), "left" === d && (s.dom.scroller.scrollTop = s.dom.grid.left.liner.scrollTop, s.s.iRightColumns > 0 && (s.dom.grid.right.liner.scrollTop = s.dom.grid.left.liner.scrollTop))
            }).on(h, function(t) {
                var e = "wheel" === t.type ? -t.originalEvent.deltaX : t.originalEvent.wheelDeltaX;
                s.dom.scroller.scrollLeft -= e
            }), s.s.iRightColumns > 0 && t(s.dom.grid.right.liner).on("mouseover.DTFC touchstart.DTFC", function() {
                a || (d = "right")
            }).on("scroll.DTFC", function(t) {
                !d && t.originalEvent && (d = "right"), "right" === d && (s.dom.scroller.scrollTop = s.dom.grid.right.liner.scrollTop, s.s.iLeftColumns > 0 && (s.dom.grid.left.liner.scrollTop = s.dom.grid.right.liner.scrollTop))
            }).on(h, function(t) {
                var e = "wheel" === t.type ? -t.originalEvent.deltaX : t.originalEvent.wheelDeltaX;
                s.dom.scroller.scrollLeft -= e
            }), t(e).on("resize.DTFC", function() {
                s._fnGridLayout.call(s)
            });
            var f = !0,
                u = t(this.s.dt.nTable);
            u.on("draw.dt.DTFC", function() {
                s._fnColCalc(), s._fnDraw.call(s, f), f = !1
            }).on("column-sizing.dt.DTFC", function() {
                s._fnColCalc(), s._fnGridLayout(s)
            }).on("column-visibility.dt.DTFC", function(t, e, o, l, r) {
                (r === i || r) && (s._fnColCalc(), s._fnGridLayout(s), s._fnDraw(!0))
            }).on("select.dt.DTFC deselect.dt.DTFC", function(t, e, o, i) {
                "dt" === t.namespace && s._fnDraw(!1)
            }).on("destroy.dt.DTFC", function() {
                u.off(".DTFC"), t(s.dom.scroller).off(".DTFC"), t(e).off(".DTFC"), t(s.s.dt.nTableWrapper).off(".DTFC"), t(s.dom.grid.left.liner).off(".DTFC " + h), t(s.dom.grid.left.wrapper).remove(), t(s.dom.grid.right.liner).off(".DTFC " + h), t(s.dom.grid.right.wrapper).remove()
            }), this._fnGridLayout(), this.s.dt.oInstance.fnDraw(!1)
        },
        _fnColCalc: function() {
            var e = this,
                o = 0,
                i = 0;
            this.s.aiInnerWidths = [], this.s.aiOuterWidths = [], t.each(this.s.dt.aoColumns, function(l, s) {
                var r, n = t(s.nTh);
                if (n.filter(":visible").length) {
                    var d = n.outerWidth();
                    0 === e.s.aiOuterWidths.length && (r = t(e.s.dt.nTable).css("border-left-width"), d += "string" == typeof r ? 1 : parseInt(r, 10)), e.s.aiOuterWidths.length === e.s.dt.aoColumns.length - 1 && (r = t(e.s.dt.nTable).css("border-right-width"), d += "string" == typeof r ? 1 : parseInt(r, 10)), e.s.aiOuterWidths.push(d), e.s.aiInnerWidths.push(n.width()), l < e.s.iLeftColumns && (o += d), e.s.iTableColumns - e.s.iRightColumns <= l && (i += d)
                } else e.s.aiInnerWidths.push(0), e.s.aiOuterWidths.push(0)
            }), this.s.iLeftWidth = o, this.s.iRightWidth = i
        },
        _fnGridSetup: function() {
            var e, o = this._fnDTOverflow();
            this.dom.body = this.s.dt.nTable, this.dom.header = this.s.dt.nTHead.parentNode, this.dom.header.parentNode.parentNode.style.position = "relative";
            var i = t('<div class="DTFC_ScrollWrapper" style="position:relative; clear:both;"><div class="DTFC_LeftWrapper" style="position:absolute; top:0; left:0;"><div class="DTFC_LeftHeadWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div><div class="DTFC_LeftBodyWrapper" style="position:relative; top:0; left:0; overflow:hidden;"><div class="DTFC_LeftBodyLiner" style="position:relative; top:0; left:0; overflow-y:scroll;"></div></div><div class="DTFC_LeftFootWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div></div><div class="DTFC_RightWrapper" style="position:absolute; top:0; right:0;"><div class="DTFC_RightHeadWrapper" style="position:relative; top:0; left:0;"><div class="DTFC_RightHeadBlocker DTFC_Blocker" style="position:absolute; top:0; bottom:0;"></div></div><div class="DTFC_RightBodyWrapper" style="position:relative; top:0; left:0; overflow:hidden;"><div class="DTFC_RightBodyLiner" style="position:relative; top:0; left:0; overflow-y:scroll;"></div></div><div class="DTFC_RightFootWrapper" style="position:relative; top:0; left:0;"><div class="DTFC_RightFootBlocker DTFC_Blocker" style="position:absolute; top:0; bottom:0;"></div></div></div></div>')[0],
                l = i.childNodes[0],
                s = i.childNodes[1];
            this.dom.grid.dt.parentNode.insertBefore(i, this.dom.grid.dt), i.appendChild(this.dom.grid.dt), this.dom.grid.wrapper = i, this.s.iLeftColumns > 0 && (this.dom.grid.left.wrapper = l, this.dom.grid.left.head = l.childNodes[0], this.dom.grid.left.body = l.childNodes[1], this.dom.grid.left.liner = t("div.DTFC_LeftBodyLiner", i)[0], i.appendChild(l)), this.s.iRightColumns > 0 && (this.dom.grid.right.wrapper = s, this.dom.grid.right.head = s.childNodes[0], this.dom.grid.right.body = s.childNodes[1], this.dom.grid.right.liner = t("div.DTFC_RightBodyLiner", i)[0], s.style.right = o.bar + "px", e = t("div.DTFC_RightHeadBlocker", i)[0], e.style.width = o.bar + "px", e.style.right = -o.bar + "px", this.dom.grid.right.headBlock = e, e = t("div.DTFC_RightFootBlocker", i)[0], e.style.width = o.bar + "px", e.style.right = -o.bar + "px", this.dom.grid.right.footBlock = e, i.appendChild(s)), this.s.dt.nTFoot && (this.dom.footer = this.s.dt.nTFoot.parentNode, this.s.iLeftColumns > 0 && (this.dom.grid.left.foot = l.childNodes[2]), this.s.iRightColumns > 0 && (this.dom.grid.right.foot = s.childNodes[2])), this.s.rtl && t("div.DTFC_RightHeadBlocker", i).css({
                left: -o.bar + "px",
                right: ""
            })
        },
        _fnGridLayout: function() {
            var e, o = this,
                i = this.dom.grid,
                l = (t(i.wrapper).width(), t(this.s.dt.nTable.parentNode).outerHeight()),
                s = t(this.s.dt.nTable.parentNode.parentNode).outerHeight(),
                r = this._fnDTOverflow(),
                n = this.s.iLeftWidth,
                d = this.s.iRightWidth,
                a = "rtl" === t(this.dom.body).css("direction"),
                h = function(e, i) {
                    r.bar ? o._firefoxScrollError() ? t(e).height() > 34 && (e.style.width = i + r.bar + "px") : e.style.width = i + r.bar + "px" : (e.style.width = i + 20 + "px", e.style.paddingRight = "20px", e.style.boxSizing = "border-box")
                };
            r.x && (l -= r.bar), i.wrapper.style.height = s + "px", this.s.iLeftColumns > 0 && (e = i.left.wrapper, e.style.width = n + "px", e.style.height = "1px", a ? (e.style.left = "", e.style.right = 0) : (e.style.left = 0, e.style.right = ""), i.left.body.style.height = l + "px", i.left.foot && (i.left.foot.style.top = (r.x ? r.bar : 0) + "px"), h(i.left.liner, n), i.left.liner.style.height = l + "px", i.left.liner.style.maxHeight = l + "px"), this.s.iRightColumns > 0 && (e = i.right.wrapper, e.style.width = d + "px", e.style.height = "1px", this.s.rtl ? (e.style.left = r.y ? r.bar + "px" : 0, e.style.right = "") : (e.style.left = "", e.style.right = r.y ? r.bar + "px" : 0), i.right.body.style.height = l + "px", i.right.foot && (i.right.foot.style.top = (r.x ? r.bar : 0) + "px"), h(i.right.liner, d), i.right.liner.style.height = l + "px", i.right.liner.style.maxHeight = l + "px", i.right.headBlock.style.display = r.y ? "block" : "none", i.right.footBlock.style.display = r.y ? "block" : "none")
        },
        _fnDTOverflow: function() {
            var t = this.s.dt.nTable,
                e = t.parentNode,
                o = {
                    x: !1,
                    y: !1,
                    bar: this.s.dt.oScroll.iBarWidth
                };
            return t.offsetWidth > e.clientWidth && (o.x = !0), t.offsetHeight > e.clientHeight && (o.y = !0), o
        },
        _fnDraw: function(e) {
            this._fnGridLayout(), this._fnCloneLeft(e), this._fnCloneRight(e), null !== this.s.fnDrawCallback && this.s.fnDrawCallback.call(this, this.dom.clone.left, this.dom.clone.right), t(this).trigger("draw.dtfc", {
                leftClone: this.dom.clone.left,
                rightClone: this.dom.clone.right
            })
        },
        _fnCloneRight: function(t) {
            if (!(this.s.iRightColumns <= 0)) {
                var e, o = [];
                for (e = this.s.iTableColumns - this.s.iRightColumns; e < this.s.iTableColumns; e++) this.s.dt.aoColumns[e].bVisible && o.push(e);
                this._fnClone(this.dom.clone.right, this.dom.grid.right, o, t)
            }
        },
        _fnCloneLeft: function(t) {
            if (!(this.s.iLeftColumns <= 0)) {
                var e, o = [];
                for (e = 0; e < this.s.iLeftColumns; e++) this.s.dt.aoColumns[e].bVisible && o.push(e);
                this._fnClone(this.dom.clone.left, this.dom.grid.left, o, t)
            }
        },
        _fnCopyLayout: function(e, o, i) {
            for (var l = [], s = [], r = [], n = 0, d = e.length; d > n; n++) {
                var a = [];
                a.nTr = t(e[n].nTr).clone(i, !1)[0];
                for (var h = 0, f = this.s.iTableColumns; f > h; h++)
                    if (-1 !== t.inArray(h, o)) {
                        var u = t.inArray(e[n][h].cell, r);
                        if (-1 === u) {
                            var c = t(e[n][h].cell).clone(i, !1)[0];
                            s.push(c), r.push(e[n][h].cell), a.push({
                                cell: c,
                                unique: e[n][h].unique
                            })
                        } else a.push({
                            cell: s[u],
                            unique: e[n][h].unique
                        })
                    }
                l.push(a)
            }
            return l
        },
        _fnClone: function(e, o, l, s) {
            var r, n, d, a, h, f, u, c, p, g, m = this,
                C = this.s.dt;
            if (s) {
                for (t(e.header).remove(), e.header = t(this.dom.header).clone(!0, !1)[0], e.header.className += " DTFC_Cloned", e.header.style.width = "100%", o.head.appendChild(e.header), c = this._fnCopyLayout(C.aoHeader, l, !0), p = t(">thead", e.header), p.empty(), r = 0, n = c.length; n > r; r++) p[0].appendChild(c[r].nTr);
                C.oApi._fnDrawHead(C, c, !0)
            } else
                for (c = this._fnCopyLayout(C.aoHeader, l, !1), g = [], C.oApi._fnDetectHeader(g, t(">thead", e.header)[0]), r = 0, n = c.length; n > r; r++)
                    for (d = 0, a = c[r].length; a > d; d++) g[r][d].cell.className = c[r][d].cell.className, t("span.DataTables_sort_icon", g[r][d].cell).each(function() {
                        this.className = t("span.DataTables_sort_icon", c[r][d].cell)[0].className
                    });
            this._fnEqualiseHeights("thead", this.dom.header, e.header), "auto" == this.s.sHeightMatch && t(">tbody>tr", m.dom.body).css("height", "auto"), null !== e.body && (t(e.body).remove(), e.body = null), e.body = t(this.dom.body).clone(!0)[0], e.body.className += " DTFC_Cloned", e.body.style.paddingBottom = C.oScroll.iBarWidth + "px", e.body.style.marginBottom = 2 * C.oScroll.iBarWidth + "px", null !== e.body.getAttribute("id") && e.body.removeAttribute("id"), t(">thead>tr", e.body).empty(), t(">tfoot", e.body).remove();
            var y = t("tbody", e.body)[0];
            if (t(y).empty(), C.aiDisplay.length > 0) {
                var T = t(">thead>tr", e.body)[0];
                for (u = 0; u < l.length; u++) {
                    h = l[u], f = t(C.aoColumns[h].nTh).clone(!0)[0], f.innerHTML = "";
                    var v = f.style;
                    v.paddingTop = "0", v.paddingBottom = "0", v.borderTopWidth = "0", v.borderBottomWidth = "0", v.height = 0, v.width = m.s.aiInnerWidths[h] + "px", T.appendChild(f)
                }
                t(">tbody>tr", m.dom.body).each(function(e) {
                    var o = m.s.dt.oFeatures.bServerSide === !1 ? m.s.dt.aiDisplay[m.s.dt._iDisplayStart + e] : e,
                        i = m.s.dt.aoData[o].anCells || t(this).children("td, th"),
                        s = this.cloneNode(!1);
                    for (s.removeAttribute("id"), s.setAttribute("data-dt-row", o), u = 0; u < l.length; u++) h = l[u], i.length > 0 && (f = t(i[h]).clone(!0, !0)[0], f.removeAttribute("id"), f.setAttribute("data-dt-row", o), f.setAttribute("data-dt-column", C.oApi._fnVisibleToColumnIndex(C, h)), s.appendChild(f));
                    y.appendChild(s)
                })
            } else t(">tbody>tr", m.dom.body).each(function(e) {
                f = this.cloneNode(!0), f.className += " DTFC_NoData", t("td", f).html(""), y.appendChild(f)
            });
            if (e.body.style.width = "100%", e.body.style.margin = "0", e.body.style.padding = "0", C.oScroller !== i) {
                var b = C.oScroller.dom.force;
                o.forcer ? o.forcer.style.height = b.style.height : (o.forcer = b.cloneNode(!0), o.liner.appendChild(o.forcer))
            }
            if (o.liner.appendChild(e.body), this._fnEqualiseHeights("tbody", m.dom.body, e.body), null !== C.nTFoot) {
                if (s) {
                    null !== e.footer && e.footer.parentNode.removeChild(e.footer), e.footer = t(this.dom.footer).clone(!0, !0)[0], e.footer.className += " DTFC_Cloned", e.footer.style.width = "100%", o.foot.appendChild(e.footer), c = this._fnCopyLayout(C.aoFooter, l, !0);
                    var _ = t(">tfoot", e.footer);
                    for (_.empty(), r = 0, n = c.length; n > r; r++) _[0].appendChild(c[r].nTr);
                    C.oApi._fnDrawHead(C, c, !0)
                } else {
                    c = this._fnCopyLayout(C.aoFooter, l, !1);
                    var D = [];
                    for (C.oApi._fnDetectHeader(D, t(">tfoot", e.footer)[0]), r = 0, n = c.length; n > r; r++)
                        for (d = 0, a = c[r].length; a > d; d++) D[r][d].cell.className = c[r][d].cell.className
                }
                this._fnEqualiseHeights("tfoot", this.dom.footer, e.footer)
            }
            var F = C.oApi._fnGetUniqueThs(C, t(">thead", e.header)[0]);
            t(F).each(function(t) {
                h = l[t], this.style.width = m.s.aiInnerWidths[h] + "px"
            }), null !== m.s.dt.nTFoot && (F = C.oApi._fnGetUniqueThs(C, t(">tfoot", e.footer)[0]), t(F).each(function(t) {
                h = l[t], this.style.width = m.s.aiInnerWidths[h] + "px"
            }))
        },
        _fnGetTrNodes: function(t) {
            for (var e = [], o = 0, i = t.childNodes.length; i > o; o++) "TR" == t.childNodes[o].nodeName.toUpperCase() && e.push(t.childNodes[o]);
            return e
        },
        _fnEqualiseHeights: function(e, o, i) {
            if ("none" != this.s.sHeightMatch || "thead" === e || "tfoot" === e) {
                var l, s, r, n, d, a = o.getElementsByTagName(e)[0],
                    h = i.getElementsByTagName(e)[0],
                    f = t(">" + e + ">tr:eq(0)", o).children(":first"),
                    u = (f.outerHeight() - f.height(), this._fnGetTrNodes(a)),
                    c = this._fnGetTrNodes(h),
                    p = [];
                for (l = 0, s = c.length; s > l; l++) n = u[l].offsetHeight, d = c[l].offsetHeight, r = d > n ? d : n, "semiauto" == this.s.sHeightMatch && (u[l]._DTTC_iHeight = r), p.push(r);
                for (l = 0, s = c.length; s > l; l++) c[l].style.height = p[l] + "px", u[l].style.height = p[l] + "px"
            }
        },
        _firefoxScrollError: function() {
            if (l === i) {
                var e = t("<div/>").css({
                    position: "absolute",
                    top: 0,
                    left: 0,
                    height: 10,
                    width: 50,
                    overflow: "scroll"
                }).appendTo("body");
                l = e[0].clientWidth === e[0].offsetWidth && 0 !== this._fnDTOverflow().bar, e.remove()
            }
            return l
        }
    }), r.defaults = {
        iLeftColumns: 1,
        iRightColumns: 0,
        fnDrawCallback: null,
        sHeightMatch: "semiauto"
    }, r.version = "3.2.3", s.Api.register("fixedColumns()", function() {
        return this
    }), s.Api.register("fixedColumns().update()", function() {
        return this.iterator("table", function(t) {
            t._oFixedColumns && t._oFixedColumns.fnUpdate()
        })
    }), s.Api.register("fixedColumns().relayout()", function() {
        return this.iterator("table", function(t) {
            t._oFixedColumns && t._oFixedColumns.fnRedrawLayout()
        })
    }), s.Api.register("rows().recalcHeight()", function() {
        return this.iterator("row", function(t, e) {
            t._oFixedColumns && t._oFixedColumns.fnRecalculateHeight(this.row(e).node())
        })
    }), s.Api.register("fixedColumns().rowIndex()", function(e) {
        return e = t(e), e.parents(".DTFC_Cloned").length ? this.rows({
            page: "current"
        }).indexes()[e.index()] : this.row(e).index()
    }), s.Api.register("fixedColumns().cellIndex()", function(e) {
        if (e = t(e), e.parents(".DTFC_Cloned").length) {
            var o, i = e.parent().index(),
                l = this.rows({
                    page: "current"
                }).indexes()[i];
            if (e.parents(".DTFC_LeftWrapper").length) o = e.index();
            else {
                var s = this.columns().flatten().length;
                o = s - this.context[0]._oFixedColumns.s.iRightColumns + e.index()
            }
            return {
                row: l,
                column: this.column.index("toData", o),
                columnVisible: o
            }
        }
        return this.cell(e).index()
    }), t(o).on("init.dt.fixedColumns", function(e, o) {
        if ("dt" === e.namespace) {
            var i = o.oInit.fixedColumns,
                l = s.defaults.fixedColumns;
            if (i || l) {
                var n = t.extend({}, i, l);
                i !== !1 && new r(o, n)
            }
        }
    }), t.fn.dataTable.FixedColumns = r, t.fn.DataTable.FixedColumns = r,




        r
});